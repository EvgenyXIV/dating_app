"""
Django settings for dating_app project.

Generated by 'django-admin startproject' using Django 5.2.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import os
from pathlib import Path
from datetime import timedelta  # для установки времени жизни токена
from decouple import config  # импортируем модуль для работы с переменными окружения

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config(
    "DEBUG", default=False, cast=bool
)  # Принимает значение, указанное в .env файле,преобразованное в тип bool
ALLOWED_HOSTS = config("DJANGO_ALLOWED_HOSTS", default="localhost,127.0.0.1").split(",")


# Application definition

INSTALLED_APPS = [
    # Приложения проекта
    "users",
    "chat",
    # Приложения Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.sites",
    # Приложения сторонние
    "rest_framework",  # Для работы с REST API
    "rest_framework_simplejwt",  # для авторизации через токен c SimpleJWT
    "rest_framework_simplejwt.token_blacklist",  # Управление списком устаревших jwt-токенов
    "corsheaders",
    "drf_yasg",
    "channels",
    "django_filters",
    "django_extensions",  # Для импорта/экспорта данных в CSV, XLSX
    # Приложения для социальной авторизации
    "allauth",
    "allauth.account",
    "allauth.socialaccount",
    "allauth.socialaccount.providers.google",
    "allauth.socialaccount.providers.yandex",
    "allauth.socialaccount.providers.mailru",
    # Приложение для физического удаления файлов при директиве "delete",
    # которая удаляет ссылки на файлы в моделях или админке
    "django_cleanup.apps.CleanupConfig",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "allauth.account.middleware.AccountMiddleware",
]
ROOT_URLCONF = "dating_app.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "dating_app.wsgi.application"

# Channels для WebSocket
ASGI_APPLICATION = "dating_app.asgi.application"
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels.layers.InMemoryChannelLayer",
    },
}

# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": config("SQL_ENGINE"),
        "NAME": config("SQL_DATABASE"),
        "USER": config("SQL_USER"),
        "PASSWORD": config("SQL_PASSWORD"),
        # "HOST": "localhost",                    # Имя хоста, если используется локальная база
        "HOST": config("SQL_HOST"),  # Имя хоста при развертывании в Docker контейнере
        "PORT": config("SQL_PORT"),
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {
            "min_length": 6,
        },
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

# LANGUAGE_CODE = 'en-us'
LANGUAGE_CODE = "ru-ru"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "/static/"  # URL для статических файлов
STATICFILES_DIRS = [BASE_DIR / "static",]   # Путь к локальным папкам для стат.файлов

STATIC_ROOT = BASE_DIR / "staticfiles"      # Папка сбора и хранения всех стат.файлов 
                                            # из всех приложений проекта при collectstatic

MEDIA_URL = "/media/"                       # URL папки для медиафайлов пользователя
MEDIA_ROOT = BASE_DIR / "media"             # Путь к папке с медиафайлами пользователя


# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

AUTH_USER_MODEL = "users.User"  # Расширяем стандартный User, для работы с профилями пользователей в проекте и в Allauth

# Настройки для REST_FRAMEWORK
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",  # Проверка авторизации
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework.authentication.SessionAuthentication",  # Авторизация через сессию (только для разработки)
        "rest_framework_simplejwt.authentication.JWTAuthentication",  # Авторизация через токен c SimpleJWT
    ),
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",  # Пагинация
    "PAGE_SIZE": 20,
    "DEFAULT_FILTER_BACKENDS": [
        "django_filters.rest_framework.DjangoFilterBackend",
        "rest_framework.filters.SearchFilter",
        "rest_framework.filters.OrderingFilter",
    ],  # Для фильтрации, поиска и сортировки
}

# Настройки для авторизации через токен c SimpleJWT - копируем из документации по SimpleJWT
# https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html
SIMPLE_JWT = {
    # Обязательно импортировать: from datetime import timedelta
    # ВременнЫе настройки
    "ACCESS_TOKEN_LIFETIME": timedelta(hours=72),  # Время жизни токена для доступа
    "REFRESH_TOKEN_LIFETIME": timedelta(
        days=10
    ),  # Время жизни токена для обновления токена доступа
    "ROTATE_REFRESH_TOKENS": True,  # требуется изменение refresh-токена и его срока после обновления access-токена
    "BLACKLIST_AFTER_ROTATION": True,  # вращения - есть и есть запись старого токена в блэклист
    "UPDATE_LAST_LOGIN": True,  # требуется обновление даты последнего входа пользователя
    # Дополнительные claims
    "JTI_CLAIM": "jti",  # Ключ(поле) для хранения идентификатора токена (JTI)
    # СЛАЙДИНГИ НЕ НАСТРОЕНЫ - ИСПОЛЬЗУЮТСЯ ACSESS И REFRESH JWT-ТОКЕНЫ
    # # Включаем слайдинги - продлеваем время жизни токенов при активности пользователя (при запросах с валидным токеном)
    # 'SLIDING_TOKEN_LIFETIME': timedelta(hours=72),       # Время жизни access-токена продлеваем на 10 часов
    # 'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=10),# Время жизни refresh-токена продлеваем на 1 день
    # 'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',    # Ключ(поле) для хранения срока жизни refresh-токена
    # Алгоритм и подпись
    "ALGORITHM": "HS256",  # Алгоритм подписи
    "SIGNING_KEY": SECRET_KEY,  # Ключ подписи=джанго-ключ
    "VERIFYING_KEY": None,  # Ключ проверки
    # Заголовки
    "AUTH_HEADER_TYPES": ("Bearer",),  # Тип заголовка аутентификации с токеном
    "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",  # Название заголовка аутентификации
    "USER_ID_FIELD": "id",  # Поле с id пользователя
    "USER_ID_CLAIM": "user_id",  # Ключ(поле) для хранения и поиска id пользователя
    # Классы токенов
    "AUTH_TOKEN_CLASSES": (
        "rest_framework_simplejwt.tokens.AccessToken",
    ),  # кортеж классов токенов,
    # допустимых для аутентификации
    "TOKEN_TYPE_CLAIM": "token_type",  # Ключ(поле) с типом токена
}

# LOGIN_REDIRECT_URL = '/accounts/3rdparty/signup/'  # или '/'
LOGIN_REDIRECT_URL = "/api/auth/jwt/callback/"
LOGOUT_REDIRECT_URL = "/"
# FRONTEND_URL = 'http://localhost:3000' # Для продакшен, нужен фронтенд
FRONTEND_URL = (
    "http://localhost:8000"  # Для бэкенд-разработки, копируем токены на веб-странице
)
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:8000",
    "http://127.0.0.1:8000",
]

# бэкенды аутентификации.которые будут использоваться в проекте
AUTHENTICATION_BACKENDS = (
    "django.contrib.auth.backends.ModelBackend",  # стандартная аутентификация Django
    "allauth.account.auth_backends.AuthenticationBackend",  # аутентификация через Allauth, Поддержка SSO (Google, Facebook, VK)
)
# Настройка email-аутентификации в Django Allauth
SITE_ID = (
    1  # ID сайта для Django Sites Framework, используется в Allauth для отправки email
)
ACCOUNT_LOGIN_METHODS = {"email"}  # Аутентификация только по email
ACCOUNT_USER_MODEL_USERNAME_FIELD = (
    None  # Поле username исключаем при авторизации (не используется в проекте)
)
ACCOUNT_USER_MODEL_EMAIL_FIELD = (
    "email"  # Указываем email основным полем при авторизации
)
ACCOUNT_UNIQUE_EMAIL = True  # Email должен быть уникальным
ACCOUNT_EMAIL_VERIFICATION = (
    "optional"  # Не требуется отправка для подтверждения email (иначе "mandatory")
)
# ACCOUNT_SIGNUP_FORM_CLASS = None                               # Отключаем кастомную форму для регистрации через соцсети
ACCOUNT_SIGNUP_FORM_CLASS = (
    "users.forms.SocialSignupForm"  # Кастомная форма для регистрации через соцсети
)
ACCOUNT_SIGNUP_FIELDS = [
    "email*",
    "password1*",
    "password2*",
]  # Email обязателен при регистрации
# ACCOUNT_RATE_LIMITS  =  {'login': '5/300'}                      # Лимит 5 попыток входа в систему за 300 секунд

SOCIALACCOUNT_AUTO_SIGNUP = (
    False  # Отключаем автоматичекое создание пользователя django-allauth
)
SOCIALACCOUNT_ADAPTER = "users.social_adapters.SocialAccountAdapter"  # Кастомный класс для обработки данных из соцсетей,
SOCIALACCOUNT_QUERY_EMAIL = True

# Social Auth настройки для авторизации через соцсети
SOCIALACCOUNT_PROVIDERS = {
    "google": {
        "SCOPE": ["profile", "email"],
        "AUTH_PARAMS": {"access_type": "online"},
        "APP": {
            "client_id": config("GOOGLE_CLIENT_ID", default=""),
            "secret": config("GOOGLE_CLIENT_SECRET", default=""),
            # 'key': ''
        },
    },
    "yandex": {
        "SCOPE": ["login:email", "login:info"],
        "AUTH_PARAMS": {
            "force_confirm": "true",  # Принудительное подтверждение DEBUG ONLY удалить в продакшен
        },
        "APP": {
            "client_id": config("YANDEX_CLIENT_ID", default=""),
            "secret": config("YANDEX_CLIENT_SECRET", default=""),
            # 'key': ''
        },
    },
    "mailru": {
        "SCOPE": ["userinfo"],
        "APP": {
            "client_id": config("MAILRU_CLIENT_ID"),
            "secret": config("MAILRU_CLIENT_SECRET"),
            # 'key': ''         # если не используется и не требуется, то закомментировать
        },
    },
}

# CORS настройки для открытого API - предоставляем фронтенду разрешение на 

if not config("CORS_ALLOW_ALL_ORIGINS", default=False, cast=bool):
    """config передаёт из .env результат (строку адресов) в параметр v объекта(labda-функции) cast,
    которая удаляет пробелы и преобразует v в список адресов."""
    CORS_ALLOWED_ORIGINS = config(
        "CORS_ALLOWED_ORIGINS",
        default="http://localhost:3000",
        cast=lambda v: [s.strip() for s in v.split(",")],
    )

CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# Swagger настройки для документации API
SWAGGER_SETTINGS = {
    "SECURITY_DEFINITIONS": {
        "Bearer": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header",
            "description": "Введите Ваш JWT токен (с Bearer и без кавычек)",
        }
    },
    "SECURITY_REQUIREMENTS": [{"Bearer": []}],
    "USE_SESSION_AUTH": True,  # Оставляем авторизацию через сессию для разработки
}

#########################################################################################################
# НАСТРОЙКИ ДЛЯ РАЗВЁРТЫВАНИЯ В КОНТЕЙНЕРЕ И ДЛЯ РАЗРАБОТКИ. !!ЗАКОММЕНТИРОВАТЬ В РЕЖИМЕ ПРОДАКШН!!

if DEBUG:
    # Разрешаем все запросы кросс-доменовые запросы (для разработки)
    CORS_ALLOW_ALL_ORIGINS = True  # на стадии разработки в .env указываем True

    # Регистрируем DjDT
    INSTALLED_APPS.append("debug_toolbar")
    # Добавляем константу для DjDT, чтобы он понимал - запросы с каких IP адресов надо обрабатывать
    # Автоопределение INTERNAL_IPS для Docker по имени и перевод в цифрвой формат *.*.*.1
    import socket

    hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
    INTERNAL_IPS = [ip[:-1] + "1" for ip in ips] + ["127.0.0.1"]

    # Добавляем прослойку для DjDT
    MIDDLEWARE.append(
        "debug_toolbar.middleware.DebugToolbarMiddleware",
    )  # Делаем последним, для продакшена не используется
else:
    pass

############################################################################################################
